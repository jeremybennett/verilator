# DESCRIPTION: DOCUMENT source run through perl to produce internals.txt file
# Use 'make internals.txt' to produce the output file

=pod

=head1 NAME

Verilator Internals

=head1 INTRODUCTION

This file discusses internal and programming details for Verilator.  It's
the first for reference for developers and debugging problems.

See also the Verilator internals presentation at http://www.veripool.org.

=head1 TOP LEVEL CODE FLOWS AND CLASSES

=head2 Verilator Flow

The main flow of Verilator can be followed by reading the Verilator.cpp
process() function:

First, the files specified on the command line are read.  Reading involves
preprocessing, then lexical analysis with Flex and parsing with Bison.
This produces an abstract syntax tree (AST) representation of the design,
which is what is visible in the F<.tree> files described below.

Verilator then makes a series of passes over the AST, progressively refining
and optimizing it.  Some of these passes are described futher in the chapter
on L</PASS DETAILS>.

=over 4

=item *

Cells in the AST first linked, which will read and parse additional files as
above.

=item *

Functions, variable and other references are linked to their definitions.

=item *

Parameters are resolved and the design is elaborated.

=item *

Verilator then performs many additional edits and optimizations on the
hierarchical design.  This includes coverage, assertions, X elimination,
inlining, constant propagation, and dead code elimination.

=item *

References in the design are then pseudo-flattened.  Each module's variables
and functions get "Scope" references.  A scope reference is an occurrence of
that un-flattened variable in the flattened hierarchy.  A module that occurs
only once in the hierarchy will have a single scope and single VarScope for
each variable.  A module that occurs twice will have a scope for each
occurrence, and two VarScopes for each variable.  This allows optimizations
to proceed across the flattened design, while still preserving the
hierarchy.

=item *

Additional edits and optimizations proceed on the pseudo-flat design.  These
include module references, function inlining, loop unrolling, variable
lifetime analysis, lookup table creation, always splitting, and logic gate
simplifications (pushing inverters, etc).

=item *

Verilator orders the code.  Best case, this results in a single "eval"
function which has all always statements flowing from top to bottom with no
loops.

=item *

Verilator mostly removes the flattening, so that code may be shared between
multiple invocations of the same module.  It localizes variables, combines
identical functions, expands macros to C primitives, adds branch prediction
hints, and performs additional constant propagation.

=item *

Verilator finally writes the C++ modules.

=back

=head2 Key Classes Used in the Verilator Flow

=over 4

=item C<AstNode>

The AST is represented at the top level by the class C<AstNode>. This abstract
class has derived classes for the individual components (e.g. C<AstGenerate>
for a generate block) or groups of components (e.g. C<AstNodeFTask> for
functions and tasks, which in turn has C<AstFunc> and C<AstTask> as derived
classes).

Each C<AstNode> has pointers to up to four children, accessed by the
C<op1p> through C<op4p> methods.  These methods are then abstracted in a
specific Ast* node class to a more specific name.  For example with the
C<AstIf> node (for C<if> statements), C<ifsp> calls C<op1p> to give the
pointer to the AST for the "then" block, while C<elsesp> calls C<op2p> to
give the pointer to the AST for the "else" block, or NULL if there is not
one.

C<AstNode> has the concept of a next and previous AST - for example the
next and previous statements in a block. Pointers to the AST for these
statements (if they exist) can be obtained using the C<back> and C<next>
methods.

It is useful to remember that the derived class C<AstNetlist> is at the top
of the tree, so checking for this class is the standard way to see if you
are at the top of the tree.

By convention, each function/method uses the variable C<nodep> as a pointer
to the C<AstNode> currently being processed.

=item C<AstNVistor>

The passes are implemented by AST visitor classes (see L</Visitor
Functions>). These are implemented by subclasses of the abstract class,
C<AstNVisitor>. Each pass creates an instance of the visitor class, which
in turn implements a method to perform the pass.

=item C<V3Graph>

A number of passes use graph algorithms, and the class C<V3Graph> is provided
to represent those graphs. Graphs are directed, and algorithms are provided to
manipulate the graphs and to output them in I<GraphViz> dot format (see
L<http://www.graphviz.org/>). C<V3Graph.h> provides documentation of this
class.

=item C<V3GraphVertex>

This is the base class for vertices in a graph. Vertices have an associated
C<fanout>, C<color> and C<rank>, which may be used in algorithms for ordering
the graph. A generic C<user>/C<userp> member variable is also provided.

Virtual methods are provided to specify the name, color, shape and style to be
used in dot output. Typically users provided derived classes from
C<V3GraphVertex> which will reimplement these methods.

Iterators are provided to access in and out edges. Typically these are used in
the form:

    for (V3GraphEdge *edgep = vertexp->inBeginp();
         edgep;
         edgep = edgep->inNextp()) {

=item C<V3GraphEdge>

This is the base class for directed edges between pairs of vertices. Edges
have an associated C<weight> and may also be made C<cutable>. A generic
C<user>/C<userp> member variable is also provided.

Accessors, C<fromp> and C<top> return the "from" and "to" vertices
respectively.

Virtual methods are provided to specify the label, color and style to be
used in dot output. Typically users provided derived classes from
C<V3GraphEdge> which will reimplement these methods.

=item C<V3GraphAlg>

This is the base class for graph algorithms. It implements a C<bool> method,
C<followEdge> which algorithms can use to decide whether an edge is
followed. This method returns true if the graph edge has non-zero weight and a
user function, C<edgeFuncp> (supplied in the constructor) returns C<true>.

A number of predefined derived algorithm classes and access methods are
provided and documented in C<V3GraphAlg.cpp>. These derived classes may
overload base class methods of C<V3GraphAlg> as required. For example
C<followEdge> can be modified to allow following of edges with weight of zero.

=back

=head2 Verilated Flow

The evaluation loop outputted by Verilator is designed to allow a single
function to perform evaluation under most situations.

On the first evaluation, the Verilated code calls initial blocks, and then
"settles" the modules, by evaluating functions (from always statements)
until all signals are stable.

On other evaluations, the Verilated code detects what input signals have
changes.  If any are clocks, it calls the appropriate sequential functions
(from always @ posedge statements).  Interspersed with sequential functions
it calls combo functions (from always @*).  After this is complete, it
detects any changes due to combo loops or internally generated clocks, and
if one is found must reevaluate the model again.

For SystemC code, the eval() function is wrapped in a SystemC SC_METHOD,
sensitive to all inputs.  (Ideally it would only be sensitive to clocks and
combo inputs, but tracing requires all signals to cause evaluation, and the
performance difference is small.)

If tracing is enabled, a callback examines all variables in the design for
changes, and writes the trace for each change.  To accelerate this process
the evaluation process records a bitmask of variables that might have
changed; if clear, checking those signals for changes may be skipped.

=head1 PASS DETAILS

This chapter goes into more details on some of the passes.

=head2 Setting Variable Scope (F<V3Scope.cpp>)

This is the first part of flattening the hiearchy, creating a C<AstScope> for
each module, and populating it with C<AstVarScope> entries for each variable
reference within the module.  In addition an instance of C<AstTopScope> is
created for the top level module.  In a later pass, all the C<AstScope>
instances will be gathered under the C<AstTopScope>.

=head2 Flattening the Hierarchy (F<V3LinkDot.cpp>)

This occurs immediately after variable scopes have been set (see L</Setting
Variable Scope (F<V3Scope.cpp>)>).  It has a number of other functions, but a
key one is that it connects all variable references to their variable
scope. In so doing it can also resolve any C<AstVarXRef> references to
variables in other modules, replacing them by C<AstVarRef> with a link to the
appropriate scope.

=head2 Sorting out Delayed Assignment (F<V3Delayed.cpp>)

Delayed assignments are also sometime called I<non-blocking assignments>.

This pass occurs late in the processing of pseudo-flattened AST, shortly
before the dependency ordering pass. Consider the following Verilog:

  always @(posedge clk) begin
     a <= b;
     b <= a;
  end

The effect is to swap C<a> and C<b>, and it is clear that to convert to a C++
model, a temporary variable will be needed.  Generically we need to replace

     a <= b;

by

     a' <= b
     a  <= a'

ensuring that the final assignment to C<a> occurs only after all uses of C<a>
elsewhere (possibly in another C<always> block with the same sensitivities).
But suppose the original assignment is conditional

     if (cond) begin
       a <= b
     end

then it may be that C<a'> never gets set. So the final assignment back will
not be correct. So the full transformation we need is:

     a' <= a   (before any uses of a)
     ...
     a' <= b   (may be many of these)
     ...
     a <= a'   (after any uses of a)

Rather than make an explicit ordering in the code sequence, two new types of
delayed assignment AST node are used.  C<AstAssignPre> is used for the initial
assignments, and when the ordering pass occurs, will be scheduled before any
ordinary delayed assignments.  Similarly C<AstAssignPost> is used for the
final assignments, and will be scheduled after any ordinary delayed
assignments.

Rather than C<'>, Verilator uses the prefix C<__Vdly__> for the temporary
variables.  The full transformation for C<<v <= exp>> is as follows.

=over 4

=item *

Declare C<__Vdly__v> (where C<v> is the full hiearchical dotted name), using
C<AstVar> and the same C<AstVarScope> as for C<v>.

=item *

Create a preassignment for C<<__Vdly__v <= exp>>, using C<AstAssignPre>.

=item *

Replace all L-value references to C<v> in delayed assignments by C<__Vdly__v>.

=item *

Create a postassignment for C<<v <= __Vdly__v>>, using C<AstAssignPre>.

=back

Assignment may be not just to a simple variable, but to a bit- or part-select.  For example:

  reg  v[2:0]
  ...
  always @(posedge clk) begin
     v[2:1] = ...

The algorithm is a considerably more complex, since we have to allow for only
parts of a variable changing, but the principle is the same.  The
transformation needs to create an array of combinatorial post-assignments, and
for this purpose creates a custom combinatorial C<always> block.  This is the
sole purpose of the C<AstAlwaysPost> ASTnode.

=head2 Ordering of Variables (F<V3Order.cpp>)

The ordering pass runs on the pseudo-flattened tree. q It makes use of the
C<OrderVistor> class to create a dependency graph showing how the variables
(wires, vectors etc) are generated (i.e. are outputs) and consumed (i.e. are
inputs) by the various logic blocks in the program.

The graph contains logic and variable nodes, with logic. In general variable
nodes have edges pointing I<to> logic nodes where the variable is consumed
(i.e. is an input), and I<from> logic nodes where the variable is generated
(i.e. is an output).  Thus the graph corresponds almost entirely of
alternating logic and variable nodes.  The one exception is with I<ACTIVE>
logic nodes (see below), which point to their associated I<ALWAYS> logic
nodes.

=head3 Logic nodes

The logic nodes, instances of class C<OrderLogicVertex>, correspond to one of
the following in the original program.

=over 4

=item Sensitivities in clocked logic

These nodes are labelled with the keyword I<ACTIVE>.  All the variables to which
the clocked logic is senstive are consumed by the ACTIVE node, and so there
are edges from these variables I<to> the ACTIVE node.  They are derived from
C<AstSenTree> nodes for clocked logic.

=item Assignment statements

These nodes are labelled with the keyword I<ASSIGNPOST>, I<ASSIGNPRE>,
I<ASSIGNW> or I<ASSIGNALIAS>, corresponding to C<AstAssignPost>,
C<AstAssignPre>, C<AstAssignW> or C<AstAssignAlias>.

Note that delayed (i.e. non-blocking) assignments do not merit their own
statement nodes. These have been transformed as described in L</Sorting out
Delayed Assignment (F<V3Delayed.cpp>)> and may appear anywhere in the output
code. There are no constraints on their ordering.  All that matters is the
ordering of their associated C<AssignPre> and C<AssignPost> nodes.

=item Always blocks

These nodes are labelled with the keyword I<ALWAYS>, I<ALWAYSPOST> or
I<ALWAYSPUBLIC> and are derived from C<AstAlways>, C<AstAlwaysPost> or
C<AstAlwaysPublic> nodes.

For sequential logic, they have edges to and from nodes representing variables
within the C<always> block which are consumed or generated.  For each consumed
variable, a pair of nodes is created, of type I<PRE> and I<POST> (more on this
in the description of variable nodes below), with edges connecting the logic
node I<to> these nodes (since they are actually generated values).

For each generated variable, a pair of nodes is created, of type I<PORD> and
I<STD>, with edges connecting the logic node I<from> the I<PORD> node and
I<to> the I<STD> node.

In addition, for clocked logic, they have an edge from the I<ACTIVE> node
defining the sensitivities of the block.  The sensitivity variables are all
consumed (i.e. inputs).

=item Other logic nodes

Coverage toggles, corresponding to C<AstCoverToggle> nodes, generate a logic node, with a labele I<COVERTOGGLE>.

=back

=head3 Variable nodes

With one exception, variable nodes, base class C<OrderVarVertex>, are created
in response to variable references, C<AstNodeVarRef> (with derived classes
C<AstVarRef> and C<AstVarXRef>), in the AST.  However the graph node is
associated, not with the variable reference, but with its scope.  See
L</Variables, Variable Scopes and Variable References> for more details about
veriable references.  How variable nodes are created depends on whether a
value is being I<generated> (i.e used as a L-value) or I<consumed> (i.e. used
as a R-value).  Any one reference may lead to the creation of either one or
two variable nodes.

The exception is for the inputs at the top level of the program, extracted
from the C<AstVarScope> of the top level module.  These top level inputs are
all pointed to by the special top level vertex, of class C<OrderInputsVertex>,
which is held in the member variable C<m_inputsVxp> of the C<OrderVisitor>
instance.

There are four derived classes of C<OrderVarVertex> used for the different
roles variables may play in the dependency graph in standard Verilog (there is
a fifth used for settle loops in the experimental NEW_ORDERING algorithm).

=over 4

=item C<OrderVarStdVertex>

Used for top level inputs, references in sensitivity trees, references in
combinatorial logic, references in post-assignments, generated references in
pre-assigments and generated references in sequential (clocked) logic.

=item C<OrderVarPreVertex>

Used for consumed references in pre-assigments and for consumed references in
sequential (clocked) logic.

=item C<OrderVarPordVertex>

Used for generated references in pre-assignments and generated references in
sequential (clocked) logic.

=item C<OrderVarPostVertex>

Used for generated references in combinatorial logic, generated references in
post-assignments and consumed references in sequential (clocked) logic.

=back

The ordering algorithm must ensure that the use of all references keeps to the
following sequence: C<OrderVarPreVertex>, C<OrderVarPordVertex>,
C<OrderVarStdVertex>, C<OrderVarPostVertex>.

B<Note.> Only one node of each type is created for each variable.  An attempt
to create another copy, will just return a reference to the existing
node. This is managed by C<OrderUser::newVarUserVertex>, with the information
held in the C<AstVarScope::user1p> field during the C<OrderVisitor> walk over
the tree.

The algorithms do not concern themselves with which derived class is
used. They exist purely to allow one variable to have a number of different
node representations in the graph. The algorithms are driven by the properties
of the edges connecting those nodes.

=head3 Edges

Edges between nodes are instances of class C<OrderEdge>.  There are two key
properties of these edges.

=over 4

=item Cutability

Some edges can be "cut" to help within the ordering algorithms.  An edge
indicates a dependency ordering for statements which reference
variables. However it may be that the dependency ordering cannot be resolved:
A depends on B, which in turn depends on A.  The only way to resolve this will
be by removing or "cutting" an edge in the graph, but this then ,eams we will
need a loop to allow the value to settle.  Edges that may be cut are marked as
I<cutable>.

=item Weight

All edges have a weight.  Edges to be cut have their weight set to zero, and
will be generally ignored by subsequent algorithms, or when printing the
graph.

The value of the weight is used to control some of the algorithms when
ordering, and also The value of non-zero weights have no impact on the
algorithms, but they to help the graph layout when printed with GraphViz
I<dot>. The key values are:

=over 8

=item C<WEIGHT_INPUT = 1>

=item C<WEIGHT_COMBO = 1>

=item C<WEIGHT_LOOPBE = 1>

Edge from inputs (only affects graph layout), cutable edge in combinatorial
logic or edge to loop begin/end.

=item C<WEIGHT_POST = 2>

Edge from post-delayed consumed variable.

=item C<WEIGHT_POST = 3>

Edge from pre-delayed consumed variable.

=item C<WEIGHT_NORMAL = 8>
=item C<WEIGHT_NORMAL = 32>

Any other edges. The weight just helps layout, but otherwise makes no difference.

=back

=back

class C<OrderEdge> has a number of derived classes, C<OrderComboCutEdge>,
C<OrderPostCutEdge> and C<OrderPreCutEdge>.  These are provided purely for the
convience provided by their constructors, which mark the edge cutable (by
default it is not) and provide a weight appropriate to the type of edge.

The algorithms make no use of the derived classes. They are purely driven by
which nodes are are connected by an instance of C<OrderEdge>, the weight of
the edge, and whether that edge is cutable.

=head3 Building the dependency graph

The logic and vertex nodes and the edges which connect them in the dependency
graph are constructed when the various statements and variable references are
encountered as the AST is walked by the C<visit> functions of class
C<OrderVisitor>.  The edges are added during this process to build the
dependency graph. The various AST nodes are dealt with as follows

=over 4

=item C<AstAlways>

=item C<AstAlwaysPost>

=item C<AstAlwaysPublic>

=item C<AstAssignAlias>

=item C<AstAssignW>

=item C<AstAssignPre>

=item C<AstAssignPost>

=item C<AstCoverToggle>

All these AST nodes are statements, and the graph logic node is constructed in
C<iterateNewStmt>. If the node is inside a clocked activation, then an edge is
added from the logic node for the sensitivity tree to the newly created logic
node for the statements. This indicates that all the sensitivity variable
references are consumed within the statement.  This is the only time there us
a dependency created between logic nodes.

B<Note.> Is this the best way of describing things? There is dependency, but
it is of a different type to a variable being consumed as a R-value.  See
commnet on C<AStSenTree> below.

=item C<AstSenTree>

This is the only place where a logic node in the dependency graph created
outside C<iterateNewStatement>. It is not needed for correctness of the
algorithm, but improves connectedness, which ultimately helps the graph
algorithms.

=item C<AstTopScope>

This creates a special node, representing the "top" of the dependency
graph. It is special in being neither a logic nor variable node and a pointer
to it is maintained in the C<OrderVisitor> member C<m_inputsVxp>. It will
eventually have edges to all variables whose scope is the top level module and
which are inputs.

=item C<AstVarScope>

Action is only taken for the C<AstVarScope> AST nodes in the top level module
which have been marked as inputs.  These are the top level inputs to the
model, and an edge of weight C<WEIGHT_INPUT = 1> is created from the "top" of
the dependency tree in C<m_inputsVxp> to var the node, indicating that the top
level node generates the value in these variable scopes.

=item C<AstNodeVarRef>

Apart for C<AstVarScope>, it is variable references (either C<AstVarRef> or
C<AstVarXRef>) which generate variable nodes in the graph. The node is
associated with the C<AstVarScope> of the variable, not the C<AstVarRef>, so
there will only be one graph node, even if the variable is referenced the same
way multiple times in the same scope.

If the reference is in a sensitivity tree, then an C<OrderVarStdVertex> is
created, with an edge of weight C<WEIGHT_MEDIUM = 8> to the associated
sensitivity logic node. This indicates that the variable is consumed by the
sensitivity.

Otherwise how the reference is treated depends on whether it is being consumed
or generated (it can't be both). Action is only taken the first time that a
variable is generated or consumed in a particular scope.

B<Note.> There is an optimization for combinatorial contexts, which considers
that a variable cannot be consumed if it has aready been generated. This seems
a reasonable assumption, given that all assignments must be blocking, for
example:

  foo = 1;
  foo = foo + 1;

There is no point in considering the second statement a consumer of C<foo>,
since it is not the value coming into the combinatorial block.  However this
can fail sometimes because the graph construction cannot see if a previous
generation was in fact conditional:

  if (cond) foo = 1;
  foo = foo + 1;

In fact foo may be consumed if the value of C<cond> was false.  This appears
to be an issue of optimization, rather than correctness however.

For variable references that are generated inside combinatorial logic, an
C<OrderVarStdVertex> is created and a I<cutable> edge of weight C<WEIGHT_COMBO
= 1> from the logic node containing the variable reference to this new
variable node is added.  This represents the fact that the logic generates
this variable's value.

To allow this edge to be cut we need a way of ensuring the variable is
eventually generated, so we create a second node of class
C<OrderVarPostVertex> with a standard (non-cutable) edge of weight
C<WEIGHT_POST = 2> from it to the logic node. So the logic node, knows tha
after all the standard variables are done, it must do a post evaluation of
this variable.

For variable references that are consumed inside combinatorial logic, an
C<OrderVarStdVertex> is created and a standard (non-cutable) edge of weight
C<WEIGHT_POST = 2> to the logic node containing the variable reference from
this new variable node is added.  This represents the fact that the logic
consumes this variable's value.  Even though it is combinatorial code, there
is no need to make the edge cutable. To resolve looping dependencies, it is
sufficient just to ensure that one of either generated of consumed variables
has cutable dependencies, and Verilator chooses to make generated variables
cutable.

Post-assignment variables in clocked code have exactly the same dependency
requirements as combinatorial variables, and are treated identically.  If we
recall from L</Sorting out Delayed Assignment (F<V3Delayed.cpp>)>,
post-assignment is where the delayed value is assigned back

 a <= a';

This is the only time C<a'> is consumed and the only time C<a> is generated.

Pre-assignment variables in clocked code have their own particular
requirements.  Again recall, this is where the delayed value is first
generated:

 a' <= a

This is the first time C<a'> is generated and the first time C<a> is consumed,
and must be treated specially because it is in the pre-assignment context.

For the generated variable (C<a'>), two nodes are created, one of class
C<OrderVarStdVertex> and one of class C<OrderVarPordVertex>. A standard edge of
weight C<WEIGHT_NORMAL = 32> from the containing logic node to each is
created, indicating that the variable is generated by the logic.

for the consumed variable (C<a>), a single node of class C<OrderVarPreVertex>
is created with a cutable edge of weight C<WEIGHT_PRE (3)> from the node to
the containing logic, indicating that the variable is consumed by the logic.

Ordinary variables in clocked code require two nodes each. For generated
variables, these are of class C<OrderVarStdVertex> and one of class
C<OrderVarPordVertex>. The first is connected by an edge of weight
C<WEIGHT_NORMAL (32)> I<to> the containing logic node, indicating it is
consumed, the second is connected by an edge of weight C<WEIGHT_NORMAL (32)>
I<from> the containing logic node, indicating it is generated.

B<Note.> The first of these may seem rather strange - why does a generated
variable require a node indicating it is also consumed?

For consumed variables, the two nodes are one of class C<OrderVarPreVertex>
and one of class C<OrderVarPostVertex>. The first is connected by an edge of
weight C<WEIGHT_NORMAL (32)> I<from> the containing logic node, indicating it
is generated, the second is connected by an edge of weight C<WEIGHT_POST (3)>
I<to> the containing logic node, indicating it is consumed.

B<Note.> Again, the first of these may seem rather strange - why does a consumed
variable require a node indicating it is also generated?

=back

=head1 CODING CONVENTIONS

=head2 Indentation style

To match the indentation of Verilator C++ sources, use 4 spaces per level,
and leave tabs at 8 columns, so every other indent level is a tab stop.

All files should contain the magic header to insure standard indentation:

    // -*- mode: C++; c-file-style: "cc-mode" -*-

This sets indentation to the cc-mode defaults.  (Verilator predates a
CC-mode change of several years ago which overrides the defaults with GNU
style indentation; the c-set-style undoes that.)

=head2 The C<astgen> script

Some of the code implementing passes is extremely repetitive, and must be
implemented for each sub-class of C<AstNode>. However, while repetitive,
there is more variability than can be handled in C++ macros.

In Verilator this is implemented by using a Perl script, C<astgen> to
pre-process the C++ code. For example in C<V3Const.cpp> this is used to
implement the C<visit()> functions for each binary operation using the
TREEOP macro.

The original C++ source code is transformed into C++ code in the C<obj_opt>
and C<obj_dbg> sub-directories (the former for the optimized version of
Verilator, the latter for the debug version). So for example C<V3Const.cpp>
into C<V3Const__gen.cpp>.

=head2 Visitor Functions

Verilator uses the I<Visitor> design pattern to implement its refinement
and optimization passes. This allows separation of the pass algorithm from
the AST on which it operates. Wikipedia provides an introduction to the
concept at L<http://en.wikipedia.org/wiki/Visitor_pattern>.

As noted above, all visitors are derived classes of C<AstNvisitor>. All
derived classes of C<AstNode> implement the C<accept> method, which takes
as argument a reference to an instance or a C<AstNVisitor> derived class
and applies the visit method of the C<AstNVisitor> to the invoking AstNode
instance (i.e. C<this>).

One possible difficulty is that a call to C<accept> may perform an edit
which destroys the node it receives as argument. The
C<acceptSubtreeReturnEdits> method of C<AstNode> is provided to apply
C<accept> and return the resulting node, even if the original node is
destroyed (if it is not destroyed it will just return the original node).

The behavior of the visitor classes is achieved by overloading the C<visit>
function for the different C<AstNode> derived classes. If a specific
implementation is not found, the system will look in turn for overloaded
implementations up the inheritance hierarchy. For example calling C<accept>
on C<AstIf> will look in turn for:

  void visit (AstIf* nodep, AstNUser* vup)
  void visit (AstNodeIf* nodep, AstNUser* vup)
  void visit (AstNodeStmt* nodep, AstNUser* vup)
  void visit (AstNode* nodep, AstNUser* vup)

There are three ways data is passed between visitor functions.

=over 4

=item 1.

A visitor-class member variable.  This is generally for passing "parent"
information down to children.  C<m_modp> is a common example.  It's set to
NULL in the constructor, where that node (C<AstModule> visitor) sets it,
then the children are iterated, then it's cleared.  Children under an
C<AstModule> will see it set, while nodes elsewhere will see it clear.  If
there can be nested items (for example an C<AstFor> under an C<AstFor>) the
variable needs to be save-set-restored in the C<AstFor> visitor, otherwise
exiting the lower for will lose the upper for's setting.

=item 2.

User attributes.  Each C<AstNode> (B<Note.> The AST node, not the visitor)
has five user attributes, which may be accessed as an integer using the
C<user1()> through C<user5()> methods, or as a pointer (of type
C<AstNuser>) using the C<user1p()> through C<user5p()> methods (a common
technique lifted from graph traversal packages).

A visitor first clears the one it wants to use by calling
C<AstNode::user#ClearTree()>, then it can mark any node's user() with whatever
data it wants.  Readers just call C<< nodep->user() >>, but may need to cast
appropriately, so you'll often see C<< nodep->userp()->castSOMETYPE() >>.  At
the top of each visitor are comments describing how the C<user()> stuff
applies to that visitor class.  For example:

    // NODE STATE
    // Cleared entire netlist
    //   AstModule::user1p()     // bool. True to inline this module

This says that at the C<AstNetlist> C<user1ClearTree()> is called.  Each
C<AstModule>'s C<user1()> is used to indicate if we're going to inline it.

These comments are important to make sure a C<user#()> on a given C<AstNode>
type is never being used for two different purposes.

Note that calling C<user#ClearTree> is fast, it doesn't walk the tree, so
it's ok to call fairly often.  For example, it's commonly called on every
module.

=item 3.

Parameters can be passed between the visitors in close to the "normal"
function caller to callee way.  This is the second C<vup> parameter of type
C<AstNuser> that is ignored on most of the visitor functions.  V3Width does
this, but it proved more messy than the above and is deprecated.  (V3Width
was nearly the first module written.  Someday this scheme may be removed,
as it slows the program down to have to pass vup everywhere.)

=back

=head2 Iterators

C<AstNode> provides a set of iterators to facilitate walking over the
tree. Each takes two arguments, a visitor, C<v>, of type C<AstNVisitor> and
an optional pointer user data, C<vup>, of type C<AstNuser*>. The second is
one of the ways to pass parameters to visitors described in L</Visitor
Functions>, but its use is no deprecated and should be used for new visitor
classes.

=over 4

=item C<iterate()>

This just applies the C<accept> method of the C<AstNode> to the visitor
function.

=item C<iterateAndNextIgnoreEdit>

Applies the C<accept> method of each C<AstNode> in a list (i.e. connected
by C<nextp> and C<backp> pointers).

=item C<iterateAndNext>

Applies the C<accept> method of each C<AstNode> in a list. If a node is
edited by the call to C<accept>, apply C<accept> again, until the node does
not change.

=item C<iterateListBackwards>

Applies the C<accept> method of each C<AstNode> in a list, starting with
the last one.

=item C<iterateChildren>

Apply the C<iterateAndNext> method on each child C<op1p> through C<op4p> in
turn.

=item C<iterateChildrenBackwards>

Apply the C<iterateListBackwards> method on each child C<op1p> through
C<op4p> in turn.

=back

=head2 Identifying derived classes

A common requirement is to identify the specific C<AstNode> class we are
dealing with. For example a visitor might not implement separate C<visit>
methods for C<AstIf> and C<AstGenIf>, but just a single method for the base
class:

  void visit (AstNodeIf* nodep, AstNUser* vup)

However that method might want to specify additional code if it is called
for C<AstGenIf>. Verilator does this by providing a C<castSOMETYPE()>
method for each possible node type, using C++ C<dynamic_cast>. This either
returns a pointer to the object cast to that type (if it is of class
C<SOMETYPE>, or a derived class of C<SOMETYPE>) or else NULL. So our
C<visit> method could use:

  if (nodep->castAstGenIf()) {
      <code specific to AstGenIf>
  }

A common test is for C<AstNetlist>, which is the node at the root of the
AST.

=head1 TESTING

For an overview of how to write a test see the BUGS section of the
Verilator primary manual.

It is important to add tests for failures as well as success (for example to
check that an error message is correctly triggered).

Tests that fail should by convenition have the suffix C<_bad> in their name,
and include C<fails =E<gt> 1> in either their C<compile> or C<execute> step as
appropriate.

=head2 Controlling the Test Driver

Test drivers are written in PERL. All invoke the main test driver script,
which can provide detailed help on all the features available when writing
a test driver.

  test_regress/t/driver.pl --help

For convenience, a summary of the most commonly used features is provided
here. All drivers require a call to C<compile> subroutine to compile the
test. For run-time tests, this is followed by a call to the C<execute>
subroutine. Both of these functions can optionally be provided with a hash
table as argument specifying additonal options.

The test driver assumes by default that the source Verilog file name
matches the PERL driver name. So a test whose driver is C<t/t_mytest.pl>
will expect a Verilog source file C<t/t_mytest.v>. This can be changed
using the C<top_filename> subroutine, for example

  top_filename("t/t_myothertest.v");

By default all tests will run with major simulators (Icarus Verilog, NC,
VCS, ModelSim) as well as Verilator, to allow results to be
compared. However if you wish a test only to be used with Verilator, you
can use the following:

  $Self->{vlt} or $Self->skip("Verilator only test");

Of the many options that can be set through arguments to C<compiler> and
C<execute>, the following are particularly useful:

=over 4

=item C<verilator_flags2>

A list of flags to be passed to verilator when compiling.

=item C<fails>

Set to 1 to indicate that the compilation or execution is intended to fail.

=back

For example the following would specify that compilation requires two
defines and is expected to fail.

  compile (
      verilator_flags2 => ["-DSMALL_CLOCK -DGATED_COMMENT"],
      fails => 1,
      );

=head2 Regression Testing for Developers

Developers will also want to call ./configure with two extra flags:

=over 4

=item --enable-ccwarn

Causes the build to stop on warnings as well as errors. A good way to
ensure no sloppy code gets added, however it can be painful when it comes
to testing, since third party code used in the tests (e.g. SystemC) may not
be warning free.

=item --enable-longtests

In addition to the standard C, SystemC and SystemPerl tests also run the
tests in the C<test_vcs>, C<test_verilated> and C<test_regress> directories
when using I<make test>.  This is disabled by default as SystemC/SystemPerl
installation problems would otherwise falsely indicate a Verilator problem.

=back

When enabling the long tests, some additional PERL modules are needed, which
you can install using cpan.

    cpan install Unix::Processors

There are some traps to avoid when running regression tests

=over 4

=item *

The regression tests will assume that you have a version of SystemPerl to
match. Typically if working on Verilator from git, also use SystemPerl from
git.

=item *

When checking the MANIFEST, the test will barf on unexpected code in the
Verilator tree. So make sure to keep any such code outside the tree.

=item *

Not all Linux systems install Perldoc by default. This is needed for the
I<--help> option to Verilator, and also for regression testing. This can be
installed using cpan:

    cpan install Pod::Perldoc

Many Linux systems also offer a standard package for this. Red
Hat/Fedora/Centos offer I<perl-Pod-Perldoc>, while Debian/Ubuntu/Linux Mint
offer I<perl-doc>.

=item *

Running regression may exhaust resources on some Linux systems, particularly
file handles and user processes. Increase these to respectively 16,384 and
4,096. The method of doing this is system dependent, but on Fedora Linux it
would require editing the C</etc/security/limits.conf> file as root.

=back

=head1 DEBUGGING

=head2 --debug

When you run with --debug there are two primary output file types placed into
the obj_dir, .tree and .dot files.

=head2 .dot output

Dot files are dumps of internal graphs in Graphviz
L<http://www.graphviz.org/> dot format.  When a dot file is dumped,
Verilator will also print a line on stdout that can be used to format the
output, for example:

    dot -Tps -o ~/a.ps obj_dir/Vtop_foo.dot

You can then print a.ps.  You may prefer gif format, which doesn't get
scaled so can be more useful with large graphs.

For dynamic graph viewing consider ZGRViewer
L<http://zvtm.sourceforge.net/zgrviewer.html>.  If you know of better
viewers let us know; ZGRViewer isn't great for large graphs.

=head2 .tree output

Tree files are dumps of the AST Tree and are produced between every major
algorithmic stage.  An example:

     NETLIST 0x90fb00 <e1> {a0}
    1: MODULE 0x912b20 <e8822> {a8}  top  L2 [P]
   *1:2: VAR 0x91a780 <e74#> {a22} @dt=0xa2e640(w32)  out_wide [O] WIRE
    1:2:1: BASICDTYPE 0xa2e640 <e2149> {e24} @dt=this(sw32)  integer kwd=integer range=[31:0]

=over 4

The following summarizes the above example dump, with more detail on each
field in the section below.

"1:2:" indicates the hierarchy of the C<VAR> is the C<op2p> pointer under
the C<MODULE>, which in turn is the C<op1p> pointer under the C<NETLIST>

"VAR" is the AstNodeType.

"0x91a780" is the address of this node.

"<e74>" means the 74th edit to the netlist was the last modification to
this node.

"{a22}" indicates this node is related to line 22 in the source filename
"a", where "a" is the first file read, "z" the 26th, and "aa" the 27th.

"@dt=0x..." indicates the address of the data type this node contains.

"w32" indicates the width is 32 bits.

"out_wide" is the name of the node, in this case the name of the variable.

"[O]" are flags which vary with the type of node, in this case it means the
variable is an output.

=back

In more detail the following fields are dumped common to all nodes. They
are produced by the C<AstNode::dump()> method:

=over 4

=item Tree Hierarchy

The dump lines begin with numbers and colons to indicate the child node
hierarchy.  As noted above in L</Key Classes Used in the Verilator Flow>,
C<AstNode> has lists of items at the same level in the AST, connected by
the C<nextp()> and C<prevp()> pointers. These appear as nodes at the same
level. For example after inlining:

     NETLIST 0x929c1c8 <e1> {a0} w0
    1: MODULE 0x92bac80 <e3144> {e14} w0  TOP_t  L1 [P]
    1:1: CELLINLINE 0x92bab18 <e3686#> {e14} w0  v -> t
    1:1: CELLINLINE 0x92bc1d8 <e3688#> {e24} w0  v__DOT__i_test_gen -> test_gen
    ...
    1: MODULE 0x92b9bb0 <e503> {e47} w0  test_gen  L3
    ...

=item AstNode type

The textual name of this node AST type (always in capitals). Many of these
correspond directly to Verilog entities (for example C<MODULE> and
C<TASK>), but others are internal to Verialtor (for example C<NETLIST> and
C<BASICDTYPE>).

=item Address of the node

A hexadecimal address of the node in memory. Useful for examining with the
debugger.

=item Last edit number

Of the form C<< <ennnn> >> or C<< <ennnn#> >> , where C<nnnn> is the number
of the last edit to modify this node. The trailing C<#> indicates the node
has been edited since the last tree dump (which typically means in the last
refinement or optimization pass). GDB can watch for this, see L</Debugging
with GDB>.

=item Source file and line

Of the form C<< {xxnnnn} >>, where C{xx} is the filename letter (or
letters) and C<nnnn> is the line number within that file. The first file is
C<a>, the 26th is C<z>, the 27th is C<aa> and so on.

=item User pointers

Shows the value of the node's user1p...user5p, if non-NULL.

=item Data type

Many nodes have an explicit data type.  "@dt=0x..." indicates the address
of the data type (AstNodeDType) this node uses.

If a data type is present and is numberic, it then prints the width of the
item. This field is a squence of flag characters and width data as follows:

C<s> if the node is signed.

C<d> if the node is a double (i.e a floating point entity).

C<w> always present, indicating this is the width field.

C<u> if the node is unsized.

C</nnnn> if the node is unsized, where C<nnnn> is the minimum width.

=item Name of the entity represented by the node if it exists

For example for a C<VAR> it is the name of the variable.

=back

Many nodes follow these fields with additional node specific
information. Thus the C<VARREF> node will print either C<[LV]> or C<[RV]>
to indicate a left value or right value, followed by the node of the
variable being referred to. For example:

    1:2:1:1: VARREF 0x92c2598 <e509> {e24} w0  clk [RV] <- VAR 0x92a2e90 <e79> {e18} w0  clk [I] INPUT

In general, examine the C<dump()> method in C<V3AstNodes.cpp> of the node
type in question to determine additional fields that may be printed.

The C<MODULE> has a list of C<CELLINLINE> nodes referred to by its
C<op1p()> pointer, connected by C<nextp()> and C<prevp()> pointers.

Similarly the C<NETLIST> has a list of modules referred to by its C<op1p()>
pointer.

=head2 Debugging with GDB

The test_regress/driver.pl script accepts --debug --gdb to start Verilator
under gdb and break when an error is hit or the program is about to exit.
You can also use --debug --gdbbt to just backtrace and then exit gdb. To
debug the Verilated executable, use --gdbsim.

If you wish to start Verilator under GDB (or another debugger), then you
can use --debug and look at the underlying invocation of verilator_dgb. For
example

  t/t_alw_dly.pl --debug

shows it invokes the command:

  ../verilator_bin_dbg --prefix Vt_alw_dly --x-assign unique --debug
    -cc -Mdir obj_dir/t_alw_dly --debug-check -f input.vc t/t_alw_dly.v

Start GDB, then C<start> with the remaining arguments.

  gdb ../verilator_bin_dbg
  ...
  (gdb) start --prefix Vt_alw_dly --x-assign unique --debug -cc -Mdir
            obj_dir/t_alw_dly --debug-check  -f input.vc t/t_alw_dly.v
            > obj_dir/t_alw_dly/vlt_compile.log
  ...
  Temporary breakpoint 1, main (argc=13, argv=0xbfffefa4, env=0xbfffefdc)
      at ../Verilator.cpp:615
  615         ios::sync_with_stdio();
  (gdb) 

You can then continue execution with breakpoints as required.

To break at a specific edit number which changed a node (presumably to find
what made a <e####> line in the tree dumps):

   watch AstNode::s_editCntGbl==####

To print a node:

   pn nodep
   # or: call nodep->dumpGdb() # aliased to "pn" in src/.gdbinit
   pnt nodep
   # or: call nodep->dumpTreeGdb()  # aliased to "pnt" in src/.gdbinit

When GDB halts, it is useful to understand that the backtrace will commonly
show the iterator functions between each invocation of C<visit> in the
backtrace. You will typically see a frame sequence something like

  ...
  visit()
  iterateChildren()
  iterateAndNext()
  accept()
  visit()
  ...

=head1 ADDING A NEW FEATURE

Generally what would you do to add a new feature?

=over 4

=item 1.

File a bug (if there isn't already) so others know what you're working on.

=item 2.

Make a testcase in the test_regress/t/t_EXAMPLE format, see L</TESTING>.

=item 3.

If grammar changes are needed, look at the git version of VerilogPerl's
src/VParseGrammar.y, as this grammar supports the full SystemVerilog
language and has a lot of back-and-forth with Verilator's grammar.  Copy
the appropriate rules to src/verilog.y and modify the productions.

=item 4.

If a new Ast type is needed, add it to V3AstNodes.h.

=back

Now you can run "test_regress/t/t_{new testcase}.pl --debug" and it'll
probably fail but you'll see a test_regress/obj_dir/t_{newtestcase}/*.tree
file which you can examine to see if the parsing worked. See also the
sections above on debugging.

Modify the later visitor functions to process the new feature as needed.

=head2 Adding a new pass

For more substantial changes you may need to add a new pass. The simplest way
to do this is to copy the C<.cpp> and C<.h> files from an existing
pass. You'll need to add a call into your pass from the C<process()> function
in C<src/verilator.cpp>.

To get your pass to build you'll need to add its binary filename to the list
in C<src/Makefile_obj.in> and reconfigure.

=head1 MISCELLANEOUS

This chapter contains commentaries on various aspects of the design of
Verilator, which don't cleanly fit in other parts of this manual.

=head2 Variables, Variable Scopes and Variable References

Verilator refers to wires, registers, vectors and the like as I<variables>.  There are a number of ways we refer to variables.  For example there is a variable declaration itself:

 reg v[1:0];

Verilator uses C<AstVar> to represent variable declarations in the AST.  What about when the variable is used:

 always @(posedge clk) begin
    v <= {v[0], clk};
 end

Each reference to C<v> is represented in Verilator using C<AstVarRef>, which
includes a link back to the declaration's C<AstVar>.  There is a variant
version of this class, C<AstVarXRef>, to deal with references to variables in
other modules. This variant is only used in the early passes, and eliminated
when the design is flattened.

How do we deal with variables having the same name in different modules, or
multiple instantiations of the same module.  For example:

 module top_mod;
 ...
 sub_mod i_sub_mod_1;
 sub_mod i_sub_mod_2;
 ...
 endmodule
 
 module sub_mod;
 ...
 reg v[1:0]
 ...

In this case there will be two instances of C<v>. Once we flatten the design,
we'll need to be explicit about this.  The solution used by Verilator is to
introduce a node, C<AstVarScope>, showing the scope to which a variable
applies.  These are created at the start of flattening (see L</Setting
Variable Scope (F<V3Scope.cpp>)>.  Each C<VarRef> now gains an additional
pointer to its associated scope.

All the C<AstVarScope> nodes for each module are collected under one
C<AstScope> node in the AST. There is one C<AstScope> for each module
instance.

The top level module also has a C<AstTopScope> node, under which its
C<AstScope> node sits.  Eventually flattening will pull all the C<AstScope>
nodes from individual module instances under C<AstTopScope>, since the link
from C<AstVarRef> nodes will make it clear the scope of an individual variable
reference.

=head2 What is C<AstCell> Used For?

C<AstCell> is just used for the instances of modules (whose declarations use C<AstModule>).

=head1 DISTRIBUTION

The latest version is available from L<http://www.veripool.org/>.

Copyright 2008-2013 by Wilson Snyder.  Verilator is free software; you can
redistribute it and/or modify it under the terms of either the GNU Lesser
General Public License Version 3 or the Perl Artistic License Version 2.0.

=cut

######################################################################
